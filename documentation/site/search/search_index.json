{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InternetRelayCat","text":"<p>If any issues are encountered, or you cannot find something here, please consult the raw version of the documentation.</p> <p>looky here</p>"},{"location":"algos/","title":"Algorithms and Modelling","text":""},{"location":"algos/#structure-chart","title":"Structure Chart","text":""},{"location":"algos/#notation","title":"Notation","text":"<ul> <li>Keywords are capitalised.</li> <li>Subroutines in the code are underlined.</li> <li>Subroutines from an external source (i.e. the C++ standard library, FTXUI, or tomlplusplus) are italicised.</li> <li>Subroutine definitions are bold and underlined</li> <li>Notation for indexing uses square brackets, and literal strings are denoted with quotation marks</li> </ul>"},{"location":"algos/#pseudocode","title":"Pseudocode","text":"<pre>\n\nBEGIN MAINPROGRAM  \n    INITIALISATION  \n        set handler to handler-constructor   \n        set colour-theme to handler.config.theme  \n        set screen to interactive-fullscreen-constructor  \n        set UI elements to default states  \n    END INITIALISATION  \n    WHILE running\n        render-elements  \n        CASEWHERE catch-event is  \n            carriage return : send-message (message-content)  \n            mousewheel up :   \n                IF scroll-amount is not lowest THEN  \n                    decrease scroll-amount  \n                ENDIF  \n            mousewheel down :   \n                IF scroll-amount is not highest THEN  \n                    increase scroll-amount  \n                ENDIF  \n            escape : quit program  \n        ENDCASE  \n        IF poll-for-messages returns true THEN  \n            receive-messages  \n            refresh-screen  \n        ENDIF  \n    ENDWHILE\nEND MAINPROGRAM  \n\nBEGIN SUBPROGRAM handler-constructor  \n    INITIALISATION  \n        set config to config-constructor  \n        set user to config.users[default-user]  \n        set server to config.server[default-server]  \n        set server-ip to convert to useable type (server.ip-address)  \n        set server-socket to socket-constructor (IPV4, TCP-socket, any, 6667, server-ip)  \n        set socket-file-descriptor to server-socket.get-socket-fd  \n    END INITIALISATION  \n    set socket to non-blocking (socket-file-descriptor)  \n    send-message (nick command)  \n    send-message (user command)  \nEND SUBPROGRAM handler-constructor  \n\nBEGIN SUBPROGRAM config-constructor  \n    INITIALISATION  \n        IF config file doesn't exist THEN  \n            create config file with defaults  \n        ENDIF  \n        set config-location to get home directory/.config/ircat/config/toml  \n    END INITIALISATION  \n    set config to parse toml file  \nEND SUBPROGRAM config-constructor  \n\nBEGIN SUBPROGRAM socket-constructor (address-family, socket-type,  \n                                            protocol, port, ip-address)  \n    INITIALISATION  \n        set member values to parameters  \n    END INITIALISATION  \n    IF set socket-file-descriptor to socket (family, socket-type, protocol) returns an error THEN  \n        print error-message  \n    ENDIF  \n    IF socket-purpose is binding THEN  \n        set socket option (reuse address, true)  \n        bind socket   \n    ELSE   \n        connect socket  \n    ENDIF  \nEND SUBPROGRAM socket-constructor  \n\nBEGIN SUBPROGRAM send-message (content)  \n    set bytes-sent to 0  \n    set total-sent to 0  \n    set length to length of content  \n    WHILE total-sent &lt; length  \n        send (content)  \n        set bytes-sent to return value of send  \n        set total-sent to total-sent + bytes-sent  \n    ENDWHILE  \nEND SUBPROGRAM send-message  \n\nBEGIN SUBPROGRAM poll-for-messages  \n    set events-count to poll (socket-file-descriptor)  \n    IF events-count &gt; 0 THEN  \n        append receive-messages to messages  \n        return true  \n    ENDIF  \nEND SUBPROGRAM poll-for-messages  \n\nBEGIN SUBPROGRAM receive-messages  \n    set buffer to array of 2048 characters  \n    set bytes-received to 0  \n    set messages to empty vector of strings  \n    set parsed-messages to empty vector of irc-messages   \n    recv (socket-file-descriptor, buffer)  \n    set bytes-received to return value of recv  \n    WHILE there are carriage returns in buffer   \n        append a slice of the buffer from the start until the next carriage return to messages  \n        remove that slice of the buffer including the carriage return  \n    ENDWHILE  \n    FOR message IN messages   \n        append parse-message (message) to parsed-messsages  \n    ENDFOR  \n    return parsed-messages  \nEND SUBPROGRAM receive-messages  \n\nBEGIN SUBPROGRAM parse-message (message)  \n    set trailing to empty string  \n    set result to empty irc-message  \n    IF message size &lt; 1 THEN  \n        return result  \n    ENDIF  \n    IF message[0] is a \":\" THEN  \n        set result.prefix to the slice of message between 1 and the first space  \n        remove that slice from message  \n    ENDIF  \n    set result.command to the slice of message from the start until the first space  \n    remove that slice from message  \n    IF message contains \" :\" THEN  \n        set trailing to the slice of message from after \" :\" until the end  \n        remove that slice from message  \n    ENDIF  \n    WHILE there are spaces in message  \n        append the slice of message from the start until the first space to result.params  \n        remove that slice from message  \n    ENDWHILE  \n    IF there are still characters in message THEN  \n        append message to result.params  \n    ENDIF  \n    append trailinig to result.params  \n    return result  \nEND SUBPROGRAM parse-message   \n\nBEGIN SUBPROGRAM render-elements  \n    set message-box to horizontal box (individual-components)\n    set components to vertical box (message-box)\n    render (render-messages)\n    render (components)\nEND SUBPROGRAM render-elements  \n\nBEGIN SUBPROGRAM render-messages  \n    set rendered to vector of elements\n    FOR message in messages\n        append vertical box (separator-bar, message.prefix, msg.params[last]) to rendered\n    ENDFOR\n    return rendered\nEND SUBPROGRAM render-messages  \n\n</pre>"},{"location":"data/","title":"Data","text":""},{"location":"data/#data-types","title":"Data Types","text":""},{"location":"data/#char-and-string","title":"Char and String","text":"<p>Chars (characters) hold a single character, while strings may hold several. In a number of languages, either directly or under the hood, strings are essentially char arrays, and either have a fixed buffer size or are accessed using a pointer such that they can be easily stored on the heap. Chars may be used to store characters representing keystrokes, i.e. to allow the user to remap key bindings in a program, or to denote modes in function parameters - though this may be more elegantly done using const ints or enum types. Strings may be used to store data such as input from the user, raw data received from another process, a buffer created from reading a file, or for constructing largely repetitive output. In IRCat, C-strings (as in, an explicit array of characters) are used relatively commonly due to the usage of syscalls, which, due to being written in C, take C-strings as parameters. Examples of this include using send and recv over a TCP socket, and a buffer of a fixed size is used when calling recv. Literal chars are used when processing events in the UI, such as \u2018\\e\u2019 and \u2018\\n\u2019 for  and  respectively. Strings (as in the variety from the C++ standard library) are used internally for everything that does not require a C-string, such as the contents of the message box, or the different fields in irc-message structs."},{"location":"data/#boolean","title":"Boolean","text":"<p>Booleans store (in theory) a single bit, and represent true or false (1 or 0). Booleans are generally used as flags for control flow. In IRCat, booleans are used in the configuration options for settings such as vim mode and 24h time (although neither of the features corresponding to such settings are fully implemented and do not yet exist in the main branch).</p>"},{"location":"data/#real","title":"Real","text":"<p>Reals store real numbers, or, more accurately, approximations of real numbers. A number of specific data types are \u2018subsets\u2019 of reals, such as floating point integers. Reals are useful for storing numbers when a significant degree of precision is required, such as an approximation of pi.</p>"},{"location":"data/#single-precision-float-point","title":"Single-precision float point","text":"<p>Single-precision float point is a way of storing numbers, and typically has a size of 32 bits. The purpose of single-precision float point is to achieve a balance between range and precision, allowing signed values with a range to the 38th order of magnitude. The double-precision floating point format uses a size of 64 bits, allowing for greater range at the expense of memory usage. Due to the reasonable balance achieved by single and double precision floating point formats, numerous languages use them as the primary data type for precise numbers. </p>"},{"location":"data/#integer","title":"Integer","text":"<p>Integers store whole numbers of various sizes. In languages such as Rust, the size must be explicitly specified - i.e. i8, u32 which represent a signed 8 bit integer and an unsigned 32 bit integer respectively. In C++, integers can be specified similarly (i.e. long or short), but if no size is specified, the size is at least 16 bits, and on 32 and 64 bit systems, the size will generally default to 32 bit. Integers are used for all manner of purposes, including storing whole numbers, defining options using const ints (to make the use of options more programmer-friendly), and indexing structures such as arrays. In IRCat, an explicit, unsigned, long integer is used to store the IP address of the server after it is converted from a string to the specified type in network-byte-order. Other uses of integers in IRCat include, but are not limited to, the socket file descriptor and the number of events returned after polling the socket. </p>"},{"location":"data/#date-and-time","title":"Date and Time","text":"<p>Data types utilised for storing dates and times are primarily used in database querying languages or similar use cases, due to the otherwise narrow reasons for having a dedicated type for handling date and time. Fun fact: Unix time is a representation of date and time that measures the number of seconds since the 1st of January, 1970 at midnight in UTC. At the time of writing plus however many seconds it took me to check, Unix time was 1748166220. Fun fact the 2nd: Unix time hit 1000000000 seconds on the 9th of September, 2001 at 01:46:40 UTC. </p>"},{"location":"data/#data-structures","title":"Data Structures","text":""},{"location":"data/#arrays","title":"Arrays","text":"<p>Arrays contain a number of elements that may be indexed. The elements in an array must all be of the same size and type, however similar concepts such as lists are often used when this is too restrictive - such as when storing several strings. The cheapest way to alter an array is to pop elements off of the end, or push new elements to the back. Arrays and lists are highly useful to contain a number of related values, especially as iterating through an array is quite efficient. Arrays may also have more than one dimension, and two-dimensional arrays are useful for representing 2D grids or matrices. In IRCat, lists are mostly used instead due to the requirement of holding strings. For example, the messages to be displayed in the UI are stored as a list of structs representing the components of an IRC command and its fields.</p>"},{"location":"data/#records","title":"Records","text":"<p>A record is broadly a data structure that contains a number of fields of potentially different types which have corresponding values. Various languages have struct data types which represent records. Records are useful for storing data that is related but of different types. In IRCat, the user and server are represented by structs which hold key information for setting up the connection. Messages are also represented with structs after being parsed. </p>"},{"location":"data/#trees","title":"Trees","text":"<p>A tree consists of a root node which branches into child nodes. Each child node can have its own child nodes and so on, however each node must have only one parent. Trees are useful in representing decision-making, or for edits in a text document in order to implement undo and redo.</p>"},{"location":"data/#sequential-file","title":"Sequential File","text":"<p>A sequential file contains entries that can be accessed in the same order they were made, and cannot be edited. The primary purpose of sequential files is for logging. </p>"},{"location":"data/#data-dictionary","title":"Data Dictionary","text":"Name Type Use Example Scope (where applicable) Member values user struct User Holding the nick, name, password, and status of the user for login. The nick is also used later to display above messages sent by the user. <code>{\"john from accounting\", \"john\", \"accounting-sucks-actually\", 8}</code> Public member of an object within main. nick (string), real name (string), password (string), status (int) server struct Server Holding the name, ip address, and channels for the server that the user is connecting to. <code>{\"Libera\", \"94.125.182.252\", [\"#esolangs\", \"#linux\", \"Guest36\"]}</code> Public member of an object within main name (string), ip address (string), channels (vector of strings). msg-data Vector of struct irc-msg Holding all of the messages that have been parsed in a format that enables easily accessing parts of the message for rendering messages. <code>[{\"lead.libera.chat\", \"NOTICE\", [\"john from accounting\", \"*** Looking up your hostname...\"]}, {\"john from accounting\", \"PRIVMSG\", [\"Gene\", \"I don't much like this accounting gig anymore\"]}]</code> Private member of object within main. Member values of struct irc-msg: prefix (string, default = \"\"), command (string), params (vector of strings). sock-fd int Stores the file descriptor of the socket that the program is using. <code>3</code> Private member of object within main. scroll-percent float Stores how far up or down the user has scrolled through the UI. <code>0.5</code> Main. channel-entries vector of strings Stores the channels dictated by the server settings in the config file. Used for selecting the user or channel to message with a dropdown menu. <code>[\"#esolangs\", \"#linux\", #Guest36]\"</code> Main. ip-bytes long unsigned int Stores the IP address of the server in a useful format. Converted from: string -&gt; C-string -&gt; long unsigned int -&gt; long unsigned int in network-byte-order. <code>1585297148</code> Constructor of class Handler. server-socket class CSocket Used for intitialising the socket and connecting to the server, as well as getting the socket file descriptor. <code>CSocket(AF_INET, SOCK_STREAM, 0, 6667, 1585297148)</code> Constructor of class Handler. Address (struct sockaddr_in), sock-fd (int), connection (int)."}]}